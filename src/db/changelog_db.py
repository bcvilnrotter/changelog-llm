"""
Changelog database interface for the changelog-llm project.
This module provides a simplified interface for interacting with the changelog database.
"""

import hashlib
import json
import os
import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any

from src.db.db_schema import init_db
from src.db.db_utils import (
    log_page, get_page_history, check_updates, mark_used_in_training, 
    get_unused_pages, get_page_revisions, get_main_pages, remove_unused_entries,
    export_to_json as db_export_to_json
)

class ChangelogDB:
    """
    A class to interact with the changelog database.
    This provides a higher-level interface for common changelog operations.
    """
    
    def __init__(self, db_path: Optional[str] = None, debug: bool = False):
        """
        Initialize the ChangelogDB.
        
        Args:
            db_path (str, optional): Path to the database file
            debug (bool, optional): Enable debug logging
        """
        # Initialize the database if it doesn't exist
        init_db(db_path)
        self.db_path = db_path
        self.debug = debug
    
    def _compute_hash(self, content: str) -> str:
        """
        Compute SHA-256 hash of content.

        Args:
            content: String content to hash

        Returns:
            Hexadecimal string of content hash
        """
        return hashlib.sha256(content.encode('utf-8')).hexdigest()
    
    def create_run(self, model_name: str, base_model: str, hyperparameters: Dict, git_commit: Optional[str] = None) -> int:
        """
        Create a new training run.
        
        Args:
            model_name (str): Name of the model being trained
            base_model (str): Name of the base model being fine-tuned
            hyperparameters (dict): Training hyperparameters
            git_commit (str, optional): Git commit hash
        
        Returns:
            int: ID of the new training run
        """
        from src.db.db_utils import create_training_run
        return create_training_run(model_name, base_model, hyperparameters, git_commit)
    
    def update_run_status(self, run_id: int, status: str, metrics: Optional[Dict] = None) -> bool:
        """
        Update the status and metrics of a training run.
        
        Args:
            run_id (int): ID of the training run
            status (str): New status ('running', 'completed', 'failed')
            metrics (dict, optional): Training metrics to save
        
        Returns:
            bool: True if update was successful
        """
        from src.db.db_utils import update_training_run_status
        return update_training_run_status(run_id, status, metrics)
    
    def add_examples(self, run_id: int, examples: List[Dict]) -> int:
        """
        Add training examples to a training run.
        
        Args:
            run_id (int): ID of the training run
            examples (list): List of example dictionaries with 'input', 'target', 
                            and optional 'type' and 'metadata'
        
        Returns:
            int: Number of examples added
        """
        from src.db.db_utils import add_training_examples
        return add_training_examples(run_id, examples)
    
    def add_output(self, run_id: int, input_text: str, output_text: str, metadata: Optional[Dict] = None) -> int:
        """
        Add a model output to a training run.
        
        Args:
            run_id (int): ID of the training run
            input_text (str): Input prompt provided to the model
            output_text (str): Output generated by the model
            metadata (dict, optional): Additional metadata about the output
        
        Returns:
            int: ID of the new output entry
        """
        from src.db.db_utils import add_model_output
        return add_model_output(run_id, input_text, output_text, metadata)
    
    def get_run(self, run_id: int) -> Optional[Dict]:
        """
        Get details of a specific training run.
        
        Args:
            run_id (int): ID of the training run
        
        Returns:
            dict: Training run details or None if not found
        """
        from src.db.db_utils import get_training_run
        return get_training_run(run_id)
    
    def get_all_runs(self) -> List[Dict]:
        """
        Get a list of all training runs.
        
        Returns:
            list: List of training run summaries
        """
        from src.db.db_utils import get_all_training_runs
        return get_all_training_runs()
    
    def get_examples(self, run_id: Optional[int] = None, example_type: Optional[str] = None, limit: Optional[int] = None) -> List[Dict]:
        """
        Get training examples, optionally filtered by run_id and type.
        
        Args:
            run_id (int, optional): Filter by training run ID
            example_type (str, optional): Filter by example type
            limit (int, optional): Limit the number of examples returned
        
        Returns:
            list: List of training examples
        """
        from src.db.db_utils import get_training_examples
        return get_training_examples(run_id, example_type, limit)

    def log_page(
        self,
        title: str,
        page_id: str,
        revision_id: str,
        content: str,
        action: str = "added"
    ) -> Dict:
        """
        Log a Wikipedia page operation.

        Args:
            title (str): Page title
            page_id (str): Wikipedia page ID
            revision_id (str): Wikipedia revision ID
            content (str): Page content
            action (str): Operation type (added/updated/removed)

        Returns:
            The created changelog entry
        """
        try:
            import logging
            logger = logging.getLogger(__name__)
            
            # Only log detailed information in debug mode
            if self.debug:
                logger.info(f"ChangelogDB.log_page called with title={title}, page_id={page_id}, revision_id={revision_id}, action={action}")
            else:
                logger.info(f"Adding page: {title} (ID: {page_id})")
            
            # Compute content hash
            content_hash = self._compute_hash(content)
            if self.debug:
                logger.debug(f"Content hash: {content_hash}")
            
            # Call the actual database function
            return log_page(title, page_id, revision_id, content_hash, action)
        except Exception as e:
            import traceback
            logger.error(f"Error in ChangelogDB.log_page: {str(e)}")
            logger.error(f"Exception type: {type(e).__name__}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            # Return a minimal entry to avoid breaking the caller
            return {"page_id": page_id, "title": title, "revision_id": revision_id, "action": action, "error": str(e)}
    
    def log_revision(
        self,
        title: str,
        page_id: str,
        revision_id: str,
        content: str,
        parent_id: str,
        revision_number: int
    ) -> Dict:
        """
        Log a revision of a Wikipedia page.

        Args:
            title (str): Page title
            page_id (str): Wikipedia page ID
            revision_id (str): Wikipedia revision ID
            content (str): Page content
            parent_id (str): ID of the parent page
            revision_number (int): Revision number (1-5, with 1 being most recent)

        Returns:
            The created changelog entry
        """
        try:
            import logging
            logger = logging.getLogger(__name__)
            
            # Only log detailed information in debug mode
            if self.debug:
                logger.info(f"ChangelogDB.log_revision called with title={title}, page_id={page_id}, revision_id={revision_id}, parent_id={parent_id}, revision_number={revision_number}")
            else:
                logger.info(f"Adding revision {revision_number} for {title}")
            
            # Compute content hash
            content_hash = self._compute_hash(content)
            if self.debug:
                logger.debug(f"Content hash: {content_hash}")
            
            # Call the actual database function
            return log_page(title, page_id, revision_id, content_hash, "added", True, parent_id, revision_number)
        except Exception as e:
            import traceback
            logger.error(f"Error in ChangelogDB.log_revision: {str(e)}")
            logger.error(f"Exception type: {type(e).__name__}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            # Return a minimal entry to avoid breaking the caller
            return {
                "page_id": page_id, 
                "title": title, 
                "revision_id": revision_id,
                "parent_id": parent_id,
                "revision_number": revision_number,
                "is_revision": True,
                "error": str(e)
            }
    
    def get_page_history(self, page_id: str) -> List[Dict]:
        """
        Get all changelog entries for a specific page.

        Args:
            page_id (str): Wikipedia page ID

        Returns:
            List of changelog entries for the page
        """
        try:
            import logging
            logger = logging.getLogger(__name__)
            
            if self.debug:
                logger.info(f"ChangelogDB.get_page_history called with page_id={page_id}")
            
            # Call the db_utils function with error handling
            result = get_page_history(page_id)
            
            if self.debug:
                logger.debug(f"Found {len(result)} entries in page history")
            return result
        except Exception as e:
            import traceback
            logger.error(f"Error in ChangelogDB.get_page_history: {str(e)}")
            if self.debug:
                logger.error(f"Exception type: {type(e).__name__}")
                logger.error(f"Traceback: {traceback.format_exc()}")
            # Return an empty list to avoid breaking the caller
            return []
    
    def check_updates(self, page_id: str, revision_id: str) -> bool:
        """
        Check if a page needs updating based on revision ID.

        Args:
            page_id (str): Wikipedia page ID
            revision_id (str): Current revision ID to check

        Returns:
            True if page needs updating, False otherwise
        """
        try:
            import logging
            logger = logging.getLogger(__name__)
            
            if self.debug:
                logger.info(f"Checking updates for page_id={page_id}, revision_id={revision_id}")
            
            # Call the db_utils function with error handling
            result = check_updates(page_id, revision_id)
            
            if self.debug:
                logger.debug(f"Page needs updating: {result}")
            return result
        except Exception as e:
            import traceback
            logger.error(f"Error in ChangelogDB.check_updates: {str(e)}")
            logger.error(f"Exception type: {type(e).__name__}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            # If there's an error, assume we need to update the page
            return True
    
    def mark_used_in_training(
        self,
        page_ids: List[str],
        model_checkpoint: str,
        training_metrics: Optional[Dict[str, Dict[str, Any]]] = None
    ) -> None:
        """
        Mark pages as used in training with associated model checkpoint.

        Args:
            page_ids (List[str]): List of page IDs used in training
            model_checkpoint (str): Hash or identifier of the model checkpoint
            training_metrics (Dict, optional): Dictionary mapping page_ids to their training metrics
        """
        mark_used_in_training(page_ids, model_checkpoint, training_metrics)
    
    def get_unused_pages(self) -> List[Dict]:
        """
        Get all pages that haven't been used in training.

        Returns:
            List of changelog entries for unused pages (including revisions)
        """
        import logging
        logger = logging.getLogger(__name__)
        
        try:
            # Try to get unused pages from the database
            result = get_unused_pages()
            
            # If we got results, return them
            if result and len(result) > 0:
                if self.debug:
                    logger.info(f"Found {len(result)} unused pages in database")
                return result
            
            # If no unused pages were found, log a message and return an empty list
            logger.info("No unused pages found in database")
            return []
        except Exception as e:
            logger.error(f"Error in get_unused_pages: {str(e)}")
            logger.error(f"Exception type: {type(e).__name__}")
            # Return an empty list to avoid breaking the caller
            return []
    
    def get_page_revisions(self, page_id: str) -> List[Dict]:
        """
        Get all revision entries for a page.

        Args:
            page_id (str): Wikipedia page ID

        Returns:
            List of revision entries for the page, sorted by revision_number
        """
        return get_page_revisions(page_id)
    
    def get_main_pages(self) -> List[Dict]:
        """
        Get all non-revision pages.

        Returns:
            List of main page entries (excluding revisions)
        """
        return get_main_pages()
    
    def remove_unused_entries(self) -> int:
        """
        Remove all entries that haven't been used in training.
        
        Returns:
            int: Number of entries removed
        """
        return remove_unused_entries()
    
    def export_to_json(self, output_path: str = "changelog_export.json") -> bool:
        """
        Export the entire database to a JSON file similar to the original changelog.json format.
        
        Args:
            output_path (str): Path to save the JSON file
        
        Returns:
            bool: True if export was successful
        """
        return db_export_to_json(output_path)

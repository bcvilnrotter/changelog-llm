"""
Database utility functions for the changelog-llm project.
This module provides common database operations for the training process.
"""
import json
import logging
import sqlite3
from datetime import datetime
from db_schema import get_db_connection

# Set up logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def create_training_run(model_name, base_model, hyperparameters, git_commit=None):
    """
    Create a new training run entry in the database.
    
    Args:
        model_name (str): Name of the model being trained
        base_model (str): Name of the base model being fine-tuned
        hyperparameters (dict): Training hyperparameters
        git_commit (str, optional): Git commit hash
    
    Returns:
        int: ID of the new training run
    """
    logger.info(f"Creating new training run for model: {model_name}")
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        hyperparameters_json = json.dumps(hyperparameters)
        start_time = datetime.now().isoformat()
        
        cursor.execute('''
        INSERT INTO training_runs 
        (start_time, model_name, base_model, status, hyperparameters, git_commit)
        VALUES (?, ?, ?, ?, ?, ?)
        ''', (start_time, model_name, base_model, 'running', hyperparameters_json, git_commit))
        
        run_id = cursor.lastrowid
        conn.commit()
        logger.info(f"Created training run with ID: {run_id}")
        return run_id
    except sqlite3.Error as e:
        conn.rollback()
        logger.error(f"Error creating training run: {e}")
        raise
    finally:
        conn.close()

def update_training_run_status(run_id, status, metrics=None):
    """
    Update the status and metrics of a training run.
    
    Args:
        run_id (int): ID of the training run
        status (str): New status ('running', 'completed', 'failed')
        metrics (dict, optional): Training metrics to save
    
    Returns:
        bool: True if update was successful
    """
    logger.info(f"Updating training run {run_id} status to {status}")
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        updates = {'status': status}
        
        if metrics:
            metrics_json = json.dumps(metrics)
            updates['metrics'] = metrics_json
        
        if status in ('completed', 'failed'):
            updates['end_time'] = datetime.now().isoformat()
        
        # Build the SET clause dynamically
        set_clauses = [f"{k} = ?" for k in updates.keys()]
        set_clause = ", ".join(set_clauses)
        
        # Build the query and parameters
        query = f"UPDATE training_runs SET {set_clause} WHERE id = ?"
        params = list(updates.values()) + [run_id]
        
        cursor.execute(query, params)
        conn.commit()
        logger.info(f"Updated training run {run_id}")
        return True
    except sqlite3.Error as e:
        conn.rollback()
        logger.error(f"Error updating training run: {e}")
        raise
    finally:
        conn.close()

def add_training_examples(run_id, examples):
    """
    Add training examples to a training run.
    
    Args:
        run_id (int): ID of the training run
        examples (list): List of example dictionaries with 'input', 'target', and optional 'type' and 'metadata'
    
    Returns:
        int: Number of examples added
    """
    logger.info(f"Adding {len(examples)} training examples to run {run_id}")
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        for example in examples:
            input_text = example.get('input', '')
            target_text = example.get('target', '')
            example_type = example.get('type', 'default')
            metadata = json.dumps(example.get('metadata', {}))
            
            cursor.execute('''
            INSERT INTO training_examples
            (run_id, input_text, target_text, example_type, metadata)
            VALUES (?, ?, ?, ?, ?)
            ''', (run_id, input_text, target_text, example_type, metadata))
        
        conn.commit()
        logger.info(f"Added {len(examples)} examples to training run {run_id}")
        return len(examples)
    except sqlite3.Error as e:
        conn.rollback()
        logger.error(f"Error adding training examples: {e}")
        raise
    finally:
        conn.close()

def add_model_output(run_id, input_text, output_text, metadata=None):
    """
    Add a model output to a training run.
    
    Args:
        run_id (int): ID of the training run
        input_text (str): Input prompt provided to the model
        output_text (str): Output generated by the model
        metadata (dict, optional): Additional metadata about the output
    
    Returns:
        int: ID of the new output entry
    """
    logger.info(f"Adding model output to run {run_id}")
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        metadata_json = json.dumps(metadata or {})
        timestamp = datetime.now().isoformat()
        
        cursor.execute('''
        INSERT INTO model_outputs
        (run_id, input_text, output_text, timestamp, metadata)
        VALUES (?, ?, ?, ?, ?)
        ''', (run_id, input_text, output_text, timestamp, metadata_json))
        
        output_id = cursor.lastrowid
        conn.commit()
        logger.info(f"Added model output with ID: {output_id}")
        return output_id
    except sqlite3.Error as e:
        conn.rollback()
        logger.error(f"Error adding model output: {e}")
        raise
    finally:
        conn.close()

def get_training_run(run_id):
    """
    Get details of a specific training run.
    
    Args:
        run_id (int): ID of the training run
    
    Returns:
        dict: Training run details or None if not found
    """
    logger.info(f"Retrieving training run {run_id}")
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM training_runs WHERE id = ?", (run_id,))
        row = cursor.fetchone()
        
        if not row:
            logger.warning(f"Training run {run_id} not found")
            return None
        
        run_data = dict(row)
        
        # Parse JSON strings
        if run_data['hyperparameters']:
            run_data['hyperparameters'] = json.loads(run_data['hyperparameters'])
        if run_data['metrics']:
            run_data['metrics'] = json.loads(run_data['metrics'])
        
        # Get training examples
        cursor.execute("SELECT * FROM training_examples WHERE run_id = ?", (run_id,))
        examples = []
        for example_row in cursor.fetchall():
            example = dict(example_row)
            if example['metadata']:
                example['metadata'] = json.loads(example['metadata'])
            examples.append(example)
        run_data['examples'] = examples
        
        # Get model outputs
        cursor.execute("SELECT * FROM model_outputs WHERE run_id = ?", (run_id,))
        outputs = []
        for output_row in cursor.fetchall():
            output = dict(output_row)
            if output['metadata']:
                output['metadata'] = json.loads(output['metadata'])
            outputs.append(output)
        run_data['outputs'] = outputs
        
        logger.info(f"Retrieved training run {run_id} with {len(examples)} examples and {len(outputs)} outputs")
        return run_data
    except sqlite3.Error as e:
        logger.error(f"Error retrieving training run: {e}")
        raise
    finally:
        conn.close()

def get_all_training_runs():
    """
    Get a list of all training runs.
    
    Returns:
        list: List of training run summaries
    """
    logger.info("Retrieving all training runs")
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT id, model_name, base_model, status, start_time, end_time FROM training_runs ORDER BY id DESC")
        
        runs = []
        for row in cursor.fetchall():
            runs.append(dict(row))
        
        logger.info(f"Retrieved {len(runs)} training runs")
        return runs
    except sqlite3.Error as e:
        logger.error(f"Error retrieving training runs: {e}")
        raise
    finally:
        conn.close()

def get_training_examples(run_id=None, example_type=None, limit=None):
    """
    Get training examples, optionally filtered by run_id and type.
    
    Args:
        run_id (int, optional): Filter by training run ID
        example_type (str, optional): Filter by example type
        limit (int, optional): Limit the number of examples returned
    
    Returns:
        list: List of training examples
    """
    logger.info(f"Retrieving training examples for run_id={run_id}, type={example_type}, limit={limit}")
    conn = get_db_connection()
    try:
        cursor = conn.cursor()
        
        query = "SELECT * FROM training_examples"
        params = []
        
        # Add WHERE conditions
        conditions = []
        if run_id is not None:
            conditions.append("run_id = ?")
            params.append(run_id)
        if example_type is not None:
            conditions.append("example_type = ?")
            params.append(example_type)
        
        if conditions:
            query += " WHERE " + " AND ".join(conditions)
        
        # Add ORDER BY and LIMIT
        query += " ORDER BY id DESC"
        if limit is not None:
            query += " LIMIT ?"
            params.append(limit)
        
        cursor.execute(query, params)
        
        examples = []
        for row in cursor.fetchall():
            example = dict(row)
            if example['metadata']:
                example['metadata'] = json.loads(example['metadata'])
            examples.append(example)
        
        logger.info(f"Retrieved {len(examples)} training examples")
        return examples
    except sqlite3.Error as e:
        logger.error(f"Error retrieving training examples: {e}")
        raise
    finally:
        conn.close()
